(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
    typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactIntl = {}, global.React));
}(this, (function (exports, React) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var React__namespace = /*#__PURE__*/_interopNamespace(React);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    var __createBinding = Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    });

    function __exportStar(m, o) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    }
    var __setModuleDefault = Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var tslib_es6 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        __extends: __extends,
        get __assign () { return __assign; },
        __rest: __rest,
        __decorate: __decorate,
        __param: __param,
        __metadata: __metadata,
        __awaiter: __awaiter,
        __generator: __generator,
        __createBinding: __createBinding,
        __exportStar: __exportStar,
        __values: __values,
        __read: __read,
        __spread: __spread,
        __spreadArrays: __spreadArrays,
        __await: __await,
        __asyncGenerator: __asyncGenerator,
        __asyncDelegator: __asyncDelegator,
        __asyncValues: __asyncValues,
        __makeTemplateObject: __makeTemplateObject,
        __importStar: __importStar,
        __importDefault: __importDefault,
        __classPrivateFieldGet: __classPrivateFieldGet,
        __classPrivateFieldSet: __classPrivateFieldSet
    });

    /**
     * Cannot do Math.log(x) / Math.log(10) bc if IEEE floating point issue
     * @param x number
     */
    function invariant(condition, message, Err) {
        if (Err === void 0) { Err = Error; }
        if (!condition) {
            throw new Err(message);
        }
    }

    function createCommonjsModule(fn, basedir, module) {
    	return module = {
    		path: basedir,
    		exports: {},
    		require: function (path, base) {
    			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    		}
    	}, fn(module, module.exports), module.exports;
    }

    function getAugmentedNamespace(n) {
    	if (n.__esModule) return n;
    	var a = Object.defineProperty({}, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var types = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNumberElement = exports.createLiteralElement = exports.isDateTimeSkeleton = exports.isNumberSkeleton = exports.isTagElement = exports.isPoundElement = exports.isPluralElement = exports.isSelectElement = exports.isTimeElement = exports.isDateElement = exports.isNumberElement = exports.isArgumentElement = exports.isLiteralElement = exports.SKELETON_TYPE = exports.TYPE = void 0;
    var TYPE;
    (function (TYPE) {
        /**
         * Raw text
         */
        TYPE[TYPE["literal"] = 0] = "literal";
        /**
         * Variable w/o any format, e.g `var` in `this is a {var}`
         */
        TYPE[TYPE["argument"] = 1] = "argument";
        /**
         * Variable w/ number format
         */
        TYPE[TYPE["number"] = 2] = "number";
        /**
         * Variable w/ date format
         */
        TYPE[TYPE["date"] = 3] = "date";
        /**
         * Variable w/ time format
         */
        TYPE[TYPE["time"] = 4] = "time";
        /**
         * Variable w/ select format
         */
        TYPE[TYPE["select"] = 5] = "select";
        /**
         * Variable w/ plural format
         */
        TYPE[TYPE["plural"] = 6] = "plural";
        /**
         * Only possible within plural argument.
         * This is the `#` symbol that will be substituted with the count.
         */
        TYPE[TYPE["pound"] = 7] = "pound";
        /**
         * XML-like tag
         */
        TYPE[TYPE["tag"] = 8] = "tag";
    })(TYPE = exports.TYPE || (exports.TYPE = {}));
    var SKELETON_TYPE;
    (function (SKELETON_TYPE) {
        SKELETON_TYPE[SKELETON_TYPE["number"] = 0] = "number";
        SKELETON_TYPE[SKELETON_TYPE["dateTime"] = 1] = "dateTime";
    })(SKELETON_TYPE = exports.SKELETON_TYPE || (exports.SKELETON_TYPE = {}));
    /**
     * Type Guards
     */
    function isLiteralElement(el) {
        return el.type === TYPE.literal;
    }
    exports.isLiteralElement = isLiteralElement;
    function isArgumentElement(el) {
        return el.type === TYPE.argument;
    }
    exports.isArgumentElement = isArgumentElement;
    function isNumberElement(el) {
        return el.type === TYPE.number;
    }
    exports.isNumberElement = isNumberElement;
    function isDateElement(el) {
        return el.type === TYPE.date;
    }
    exports.isDateElement = isDateElement;
    function isTimeElement(el) {
        return el.type === TYPE.time;
    }
    exports.isTimeElement = isTimeElement;
    function isSelectElement(el) {
        return el.type === TYPE.select;
    }
    exports.isSelectElement = isSelectElement;
    function isPluralElement(el) {
        return el.type === TYPE.plural;
    }
    exports.isPluralElement = isPluralElement;
    function isPoundElement(el) {
        return el.type === TYPE.pound;
    }
    exports.isPoundElement = isPoundElement;
    function isTagElement(el) {
        return el.type === TYPE.tag;
    }
    exports.isTagElement = isTagElement;
    function isNumberSkeleton(el) {
        return !!(el && typeof el === 'object' && el.type === 0 /* number */);
    }
    exports.isNumberSkeleton = isNumberSkeleton;
    function isDateTimeSkeleton(el) {
        return !!(el && typeof el === 'object' && el.type === 1 /* dateTime */);
    }
    exports.isDateTimeSkeleton = isDateTimeSkeleton;
    function createLiteralElement(value) {
        return {
            type: TYPE.literal,
            value: value,
        };
    }
    exports.createLiteralElement = createLiteralElement;
    function createNumberElement(value, style) {
        return {
            type: TYPE.number,
            value: value,
            style: style,
        };
    }
    exports.createNumberElement = createNumberElement;
    });

    var tslib_1 = /*@__PURE__*/getAugmentedNamespace(tslib_es6);

    var dummy = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = void 0;

    tslib_1.__exportStar(types, exports);
    function parse() {
        throw new Error("You're trying to format an uncompiled message with react-intl without parser, please import from 'react-int' instead");
    }
    exports.parse = parse;
    });

    //
    // Main
    //

    function memoize (fn, options) {
      var cache = options && options.cache
        ? options.cache
        : cacheDefault;

      var serializer = options && options.serializer
        ? options.serializer
        : serializerDefault;

      var strategy = options && options.strategy
        ? options.strategy
        : strategyDefault;

      return strategy(fn, {
        cache: cache,
        serializer: serializer
      })
    }

    //
    // Strategy
    //

    function isPrimitive (value) {
      return value == null || typeof value === 'number' || typeof value === 'boolean' // || typeof value === "string" 'unsafe' primitive for our needs
    }

    function monadic (fn, cache, serializer, arg) {
      var cacheKey = isPrimitive(arg) ? arg : serializer(arg);

      var computedValue = cache.get(cacheKey);
      if (typeof computedValue === 'undefined') {
        computedValue = fn.call(this, arg);
        cache.set(cacheKey, computedValue);
      }

      return computedValue
    }

    function variadic (fn, cache, serializer) {
      var args = Array.prototype.slice.call(arguments, 3);
      var cacheKey = serializer(args);

      var computedValue = cache.get(cacheKey);
      if (typeof computedValue === 'undefined') {
        computedValue = fn.apply(this, args);
        cache.set(cacheKey, computedValue);
      }

      return computedValue
    }

    function assemble (fn, context, strategy, cache, serialize) {
      return strategy.bind(
        context,
        fn,
        cache,
        serialize
      )
    }

    function strategyDefault (fn, options) {
      var strategy = fn.length === 1 ? monadic : variadic;

      return assemble(
        fn,
        this,
        strategy,
        options.cache.create(),
        options.serializer
      )
    }

    function strategyVariadic (fn, options) {
      var strategy = variadic;

      return assemble(
        fn,
        this,
        strategy,
        options.cache.create(),
        options.serializer
      )
    }

    function strategyMonadic (fn, options) {
      var strategy = monadic;

      return assemble(
        fn,
        this,
        strategy,
        options.cache.create(),
        options.serializer
      )
    }

    //
    // Serializer
    //

    function serializerDefault () {
      return JSON.stringify(arguments)
    }

    //
    // Cache
    //

    function ObjectWithoutPrototypeCache () {
      this.cache = Object.create(null);
    }

    ObjectWithoutPrototypeCache.prototype.has = function (key) {
      return (key in this.cache)
    };

    ObjectWithoutPrototypeCache.prototype.get = function (key) {
      return this.cache[key]
    };

    ObjectWithoutPrototypeCache.prototype.set = function (key, value) {
      this.cache[key] = value;
    };

    var cacheDefault = {
      create: function create () {
        return new ObjectWithoutPrototypeCache()
      }
    };

    //
    // API
    //

    var src = memoize;
    var strategies = {
      variadic: strategyVariadic,
      monadic: strategyMonadic
    };
    src.strategies = strategies;

    var memoize$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), src, {
        'default': src,
        strategies: strategies
    }));

    var ErrorCode;
    (function (ErrorCode) {
        // When we have a placeholder but no value to format
        ErrorCode["MISSING_VALUE"] = "MISSING_VALUE";
        // When value supplied is invalid
        ErrorCode["INVALID_VALUE"] = "INVALID_VALUE";
        // When we need specific Intl API but it's not available
        ErrorCode["MISSING_INTL_API"] = "MISSING_INTL_API";
    })(ErrorCode || (ErrorCode = {}));
    var FormatError = /** @class */ (function (_super) {
        __extends(FormatError, _super);
        function FormatError(msg, code, originalMessage) {
            var _this = _super.call(this, msg) || this;
            _this.code = code;
            _this.originalMessage = originalMessage;
            return _this;
        }
        FormatError.prototype.toString = function () {
            return "[formatjs Error: " + this.code + "] " + this.message;
        };
        return FormatError;
    }(Error));
    var InvalidValueError = /** @class */ (function (_super) {
        __extends(InvalidValueError, _super);
        function InvalidValueError(variableId, value, options, originalMessage) {
            return _super.call(this, "Invalid values for \"" + variableId + "\": \"" + value + "\". Options are \"" + Object.keys(options).join('", "') + "\"", "INVALID_VALUE" /* INVALID_VALUE */, originalMessage) || this;
        }
        return InvalidValueError;
    }(FormatError));
    var InvalidValueTypeError = /** @class */ (function (_super) {
        __extends(InvalidValueTypeError, _super);
        function InvalidValueTypeError(value, type, originalMessage) {
            return _super.call(this, "Value for \"" + value + "\" must be of type " + type, "INVALID_VALUE" /* INVALID_VALUE */, originalMessage) || this;
        }
        return InvalidValueTypeError;
    }(FormatError));
    var MissingValueError = /** @class */ (function (_super) {
        __extends(MissingValueError, _super);
        function MissingValueError(variableId, originalMessage) {
            return _super.call(this, "The intl string context variable \"" + variableId + "\" was not provided to the string \"" + originalMessage + "\"", "MISSING_VALUE" /* MISSING_VALUE */, originalMessage) || this;
        }
        return MissingValueError;
    }(FormatError));

    var PART_TYPE;
    (function (PART_TYPE) {
        PART_TYPE[PART_TYPE["literal"] = 0] = "literal";
        PART_TYPE[PART_TYPE["object"] = 1] = "object";
    })(PART_TYPE || (PART_TYPE = {}));
    function mergeLiteral(parts) {
        if (parts.length < 2) {
            return parts;
        }
        return parts.reduce(function (all, part) {
            var lastPart = all[all.length - 1];
            if (!lastPart ||
                lastPart.type !== 0 /* literal */ ||
                part.type !== 0 /* literal */) {
                all.push(part);
            }
            else {
                lastPart.value += part.value;
            }
            return all;
        }, []);
    }
    function isFormatXMLElementFn(el) {
        return typeof el === 'function';
    }
    // TODO(skeleton): add skeleton support
    function formatToParts(els, locales, formatters, formats, values, currentPluralValue, 
    // For debugging
    originalMessage) {
        // Hot path for straight simple msg translations
        if (els.length === 1 && dummy.isLiteralElement(els[0])) {
            return [
                {
                    type: 0 /* literal */,
                    value: els[0].value,
                },
            ];
        }
        var result = [];
        for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
            var el = els_1[_i];
            // Exit early for string parts.
            if (dummy.isLiteralElement(el)) {
                result.push({
                    type: 0 /* literal */,
                    value: el.value,
                });
                continue;
            }
            // TODO: should this part be literal type?
            // Replace `#` in plural rules with the actual numeric value.
            if (dummy.isPoundElement(el)) {
                if (typeof currentPluralValue === 'number') {
                    result.push({
                        type: 0 /* literal */,
                        value: formatters.getNumberFormat(locales).format(currentPluralValue),
                    });
                }
                continue;
            }
            var varName = el.value;
            // Enforce that all required values are provided by the caller.
            if (!(values && varName in values)) {
                throw new MissingValueError(varName, originalMessage);
            }
            var value = values[varName];
            if (dummy.isArgumentElement(el)) {
                if (!value || typeof value === 'string' || typeof value === 'number') {
                    value =
                        typeof value === 'string' || typeof value === 'number'
                            ? String(value)
                            : '';
                }
                result.push({
                    type: typeof value === 'string' ? 0 /* literal */ : 1 /* object */,
                    value: value,
                });
                continue;
            }
            // Recursively format plural and select parts' option — which can be a
            // nested pattern structure. The choosing of the option to use is
            // abstracted-by and delegated-to the part helper object.
            if (dummy.isDateElement(el)) {
                var style = typeof el.style === 'string'
                    ? formats.date[el.style]
                    : dummy.isDateTimeSkeleton(el.style)
                        ? el.style.parsedOptions
                        : undefined;
                result.push({
                    type: 0 /* literal */,
                    value: formatters
                        .getDateTimeFormat(locales, style)
                        .format(value),
                });
                continue;
            }
            if (dummy.isTimeElement(el)) {
                var style = typeof el.style === 'string'
                    ? formats.time[el.style]
                    : dummy.isDateTimeSkeleton(el.style)
                        ? el.style.parsedOptions
                        : undefined;
                result.push({
                    type: 0 /* literal */,
                    value: formatters
                        .getDateTimeFormat(locales, style)
                        .format(value),
                });
                continue;
            }
            if (dummy.isNumberElement(el)) {
                var style = typeof el.style === 'string'
                    ? formats.number[el.style]
                    : dummy.isNumberSkeleton(el.style)
                        ? el.style.parsedOptions
                        : undefined;
                result.push({
                    type: 0 /* literal */,
                    value: formatters
                        .getNumberFormat(locales, style)
                        .format(value),
                });
                continue;
            }
            if (dummy.isTagElement(el)) {
                var children = el.children, value_1 = el.value;
                var formatFn = values[value_1];
                if (!isFormatXMLElementFn(formatFn)) {
                    throw new InvalidValueTypeError(value_1, 'function', originalMessage);
                }
                var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);
                var chunks = formatFn(parts.map(function (p) { return p.value; }));
                if (!Array.isArray(chunks)) {
                    chunks = [chunks];
                }
                result.push.apply(result, chunks.map(function (c) {
                    return {
                        type: typeof c === 'string' ? 0 /* literal */ : 1 /* object */,
                        value: c,
                    };
                }));
            }
            if (dummy.isSelectElement(el)) {
                var opt = el.options[value] || el.options.other;
                if (!opt) {
                    throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
                }
                result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));
                continue;
            }
            if (dummy.isPluralElement(el)) {
                var opt = el.options["=" + value];
                if (!opt) {
                    if (!Intl.PluralRules) {
                        throw new FormatError("Intl.PluralRules is not available in this environment.\nTry polyfilling it using \"@formatjs/intl-pluralrules\"\n", "MISSING_INTL_API" /* MISSING_INTL_API */, originalMessage);
                    }
                    var rule = formatters
                        .getPluralRules(locales, { type: el.pluralType })
                        .select(value - (el.offset || 0));
                    opt = el.options[rule] || el.options.other;
                }
                if (!opt) {
                    throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
                }
                result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));
                continue;
            }
        }
        return mergeLiteral(result);
    }

    /*
    Copyright (c) 2014, Yahoo! Inc. All rights reserved.
    Copyrights licensed under the New BSD License.
    See the accompanying LICENSE file for terms.
    */
    // -- MessageFormat --------------------------------------------------------
    function mergeConfig(c1, c2) {
        if (!c2) {
            return c1;
        }
        return __assign(__assign(__assign({}, (c1 || {})), (c2 || {})), Object.keys(c1).reduce(function (all, k) {
            all[k] = __assign(__assign({}, c1[k]), (c2[k] || {}));
            return all;
        }, {}));
    }
    function mergeConfigs(defaultConfig, configs) {
        if (!configs) {
            return defaultConfig;
        }
        return Object.keys(defaultConfig).reduce(function (all, k) {
            all[k] = mergeConfig(defaultConfig[k], configs[k]);
            return all;
        }, __assign({}, defaultConfig));
    }
    function createFastMemoizeCache(store) {
        return {
            create: function () {
                return {
                    has: function (key) {
                        return key in store;
                    },
                    get: function (key) {
                        return store[key];
                    },
                    set: function (key, value) {
                        store[key] = value;
                    },
                };
            },
        };
    }
    // @ts-ignore this is to deal with rollup's default import shenanigans
    var _memoizeIntl = src || memoize$1;
    var memoizeIntl = _memoizeIntl;
    function createDefaultFormatters(cache) {
        if (cache === void 0) { cache = {
            number: {},
            dateTime: {},
            pluralRules: {},
        }; }
        return {
            getNumberFormat: memoizeIntl(function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return new ((_a = Intl.NumberFormat).bind.apply(_a, __spreadArrays([void 0], args)))();
            }, {
                cache: createFastMemoizeCache(cache.number),
                strategy: memoizeIntl.strategies.variadic,
            }),
            getDateTimeFormat: memoizeIntl(function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return new ((_a = Intl.DateTimeFormat).bind.apply(_a, __spreadArrays([void 0], args)))();
            }, {
                cache: createFastMemoizeCache(cache.dateTime),
                strategy: memoizeIntl.strategies.variadic,
            }),
            getPluralRules: memoizeIntl(function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return new ((_a = Intl.PluralRules).bind.apply(_a, __spreadArrays([void 0], args)))();
            }, {
                cache: createFastMemoizeCache(cache.pluralRules),
                strategy: memoizeIntl.strategies.variadic,
            }),
        };
    }
    var IntlMessageFormat = /** @class */ (function () {
        function IntlMessageFormat(message, locales, overrideFormats, opts) {
            var _this = this;
            if (locales === void 0) { locales = IntlMessageFormat.defaultLocale; }
            this.formatterCache = {
                number: {},
                dateTime: {},
                pluralRules: {},
            };
            this.format = function (values) {
                var parts = _this.formatToParts(values);
                // Hot path for straight simple msg translations
                if (parts.length === 1) {
                    return parts[0].value;
                }
                var result = parts.reduce(function (all, part) {
                    if (!all.length ||
                        part.type !== 0 /* literal */ ||
                        typeof all[all.length - 1] !== 'string') {
                        all.push(part.value);
                    }
                    else {
                        all[all.length - 1] += part.value;
                    }
                    return all;
                }, []);
                if (result.length <= 1) {
                    return result[0] || '';
                }
                return result;
            };
            this.formatToParts = function (values) {
                return formatToParts(_this.ast, _this.locales, _this.formatters, _this.formats, values, undefined, _this.message);
            };
            this.resolvedOptions = function () { return ({
                locale: Intl.NumberFormat.supportedLocalesOf(_this.locales)[0],
            }); };
            this.getAst = function () { return _this.ast; };
            if (typeof message === 'string') {
                this.message = message;
                if (!IntlMessageFormat.__parse) {
                    throw new TypeError('IntlMessageFormat.__parse must be set to process `message` of type `string`');
                }
                // Parse string messages into an AST.
                this.ast = IntlMessageFormat.__parse(message, {
                    normalizeHashtagInPlural: false,
                    ignoreTag: opts === null || opts === void 0 ? void 0 : opts.ignoreTag,
                });
            }
            else {
                this.ast = message;
            }
            if (!Array.isArray(this.ast)) {
                throw new TypeError('A message must be provided as a String or AST.');
            }
            // Creates a new object with the specified `formats` merged with the default
            // formats.
            this.formats = mergeConfigs(IntlMessageFormat.formats, overrideFormats);
            // Defined first because it's used to build the format pattern.
            this.locales = locales;
            this.formatters =
                (opts && opts.formatters) || createDefaultFormatters(this.formatterCache);
        }
        Object.defineProperty(IntlMessageFormat, "defaultLocale", {
            get: function () {
                if (!IntlMessageFormat.memoizedDefaultLocale) {
                    IntlMessageFormat.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale;
                }
                return IntlMessageFormat.memoizedDefaultLocale;
            },
            enumerable: false,
            configurable: true
        });
        IntlMessageFormat.memoizedDefaultLocale = null;
        IntlMessageFormat.__parse = dummy.parse;
        // Default format options used as the prototype of the `formats` provided to the
        // constructor. These are used when constructing the internal Intl.NumberFormat
        // and Intl.DateTimeFormat instances.
        IntlMessageFormat.formats = {
            number: {
                currency: {
                    style: 'currency',
                },
                percent: {
                    style: 'percent',
                },
            },
            date: {
                short: {
                    month: 'numeric',
                    day: 'numeric',
                    year: '2-digit',
                },
                medium: {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                },
                long: {
                    month: 'long',
                    day: 'numeric',
                    year: 'numeric',
                },
                full: {
                    weekday: 'long',
                    month: 'long',
                    day: 'numeric',
                    year: 'numeric',
                },
            },
            time: {
                short: {
                    hour: 'numeric',
                    minute: 'numeric',
                },
                medium: {
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                },
                long: {
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                    timeZoneName: 'short',
                },
                full: {
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                    timeZoneName: 'short',
                },
            },
        };
        return IntlMessageFormat;
    }());

    (function (IntlErrorCode) {
        IntlErrorCode["FORMAT_ERROR"] = "FORMAT_ERROR";
        IntlErrorCode["UNSUPPORTED_FORMATTER"] = "UNSUPPORTED_FORMATTER";
        IntlErrorCode["INVALID_CONFIG"] = "INVALID_CONFIG";
        IntlErrorCode["MISSING_DATA"] = "MISSING_DATA";
        IntlErrorCode["MISSING_TRANSLATION"] = "MISSING_TRANSLATION";
    })(exports.ReactIntlErrorCode || (exports.ReactIntlErrorCode = {}));
    var IntlError = /** @class */ (function (_super) {
        __extends(IntlError, _super);
        function IntlError(code, message, exception) {
            var _this = _super.call(this, "[@formatjs/intl Error " + code + "] " + message + " \n" + (exception ? "\n" + exception.message + "\n" + exception.stack : '')) || this;
            _this.code = code;
            if (typeof Error.captureStackTrace === 'function') {
                Error.captureStackTrace(_this, IntlError);
            }
            return _this;
        }
        return IntlError;
    }(Error));
    var UnsupportedFormatterError = /** @class */ (function (_super) {
        __extends(UnsupportedFormatterError, _super);
        function UnsupportedFormatterError(message, exception) {
            return _super.call(this, "UNSUPPORTED_FORMATTER" /* UNSUPPORTED_FORMATTER */, message, exception) || this;
        }
        return UnsupportedFormatterError;
    }(IntlError));
    var InvalidConfigError = /** @class */ (function (_super) {
        __extends(InvalidConfigError, _super);
        function InvalidConfigError(message, exception) {
            return _super.call(this, "INVALID_CONFIG" /* INVALID_CONFIG */, message, exception) || this;
        }
        return InvalidConfigError;
    }(IntlError));
    var MissingDataError = /** @class */ (function (_super) {
        __extends(MissingDataError, _super);
        function MissingDataError(message, exception) {
            return _super.call(this, "MISSING_DATA" /* MISSING_DATA */, message, exception) || this;
        }
        return MissingDataError;
    }(IntlError));
    var MessageFormatError = /** @class */ (function (_super) {
        __extends(MessageFormatError, _super);
        function MessageFormatError(message, locale, descriptor, exception) {
            var _this = _super.call(this, "FORMAT_ERROR" /* FORMAT_ERROR */, message + " \nLocale: " + locale + "\nMessageID: " + (descriptor === null || descriptor === void 0 ? void 0 : descriptor.id) + "\nDefault Message: " + (descriptor === null || descriptor === void 0 ? void 0 : descriptor.defaultMessage) + "\nDescription: " + (descriptor === null || descriptor === void 0 ? void 0 : descriptor.description) + " \n", exception) || this;
            _this.descriptor = descriptor;
            return _this;
        }
        return MessageFormatError;
    }(IntlError));
    var MissingTranslationError = /** @class */ (function (_super) {
        __extends(MissingTranslationError, _super);
        function MissingTranslationError(descriptor, locale) {
            var _this = _super.call(this, "MISSING_TRANSLATION" /* MISSING_TRANSLATION */, "Missing message: \"" + descriptor.id + "\" for locale \"" + locale + "\", using " + (descriptor.defaultMessage ? 'default message' : 'id') + " as fallback.") || this;
            _this.descriptor = descriptor;
            return _this;
        }
        return MissingTranslationError;
    }(IntlError));

    function filterProps(props, whitelist, defaults) {
        if (defaults === void 0) { defaults = {}; }
        return whitelist.reduce(function (filtered, name) {
            if (name in props) {
                filtered[name] = props[name];
            }
            else if (name in defaults) {
                filtered[name] = defaults[name];
            }
            return filtered;
        }, {});
    }
    var defaultErrorHandler = function (error) {
    };
    var DEFAULT_INTL_CONFIG = {
        formats: {},
        messages: {},
        timeZone: undefined,
        defaultLocale: 'en',
        defaultFormats: {},
        onError: defaultErrorHandler,
    };
    function createIntlCache() {
        return {
            dateTime: {},
            number: {},
            message: {},
            relativeTime: {},
            pluralRules: {},
            list: {},
            displayNames: {},
        };
    }
    function createFastMemoizeCache$1(store) {
        return {
            create: function () {
                return {
                    has: function (key) {
                        return key in store;
                    },
                    get: function (key) {
                        return store[key];
                    },
                    set: function (key, value) {
                        store[key] = value;
                    },
                };
            },
        };
    }
    // @ts-ignore this is to deal with rollup's default import shenanigans
    var _memoizeIntl$1 = src || memoize$1;
    var memoizeIntl$1 = _memoizeIntl$1;
    /**
     * Create intl formatters and populate cache
     * @param cache explicit cache to prevent leaking memory
     */
    function createFormatters(cache) {
        if (cache === void 0) { cache = createIntlCache(); }
        var RelativeTimeFormat = Intl.RelativeTimeFormat;
        var ListFormat = Intl.ListFormat;
        var DisplayNames = Intl.DisplayNames;
        var getDateTimeFormat = memoizeIntl$1(function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new ((_a = Intl.DateTimeFormat).bind.apply(_a, __spreadArrays([void 0], args)))();
        }, {
            cache: createFastMemoizeCache$1(cache.dateTime),
            strategy: memoizeIntl$1.strategies.variadic,
        });
        var getNumberFormat = memoizeIntl$1(function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new ((_a = Intl.NumberFormat).bind.apply(_a, __spreadArrays([void 0], args)))();
        }, {
            cache: createFastMemoizeCache$1(cache.number),
            strategy: memoizeIntl$1.strategies.variadic,
        });
        var getPluralRules = memoizeIntl$1(function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new ((_a = Intl.PluralRules).bind.apply(_a, __spreadArrays([void 0], args)))();
        }, {
            cache: createFastMemoizeCache$1(cache.pluralRules),
            strategy: memoizeIntl$1.strategies.variadic,
        });
        return {
            getDateTimeFormat: getDateTimeFormat,
            getNumberFormat: getNumberFormat,
            getMessageFormat: memoizeIntl$1(function (message, locales, overrideFormats, opts) {
                return new IntlMessageFormat(message, locales, overrideFormats, __assign({ formatters: {
                        getNumberFormat: getNumberFormat,
                        getDateTimeFormat: getDateTimeFormat,
                        getPluralRules: getPluralRules,
                    } }, (opts || {})));
            }, {
                cache: createFastMemoizeCache$1(cache.message),
                strategy: memoizeIntl$1.strategies.variadic,
            }),
            getRelativeTimeFormat: memoizeIntl$1(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return new (RelativeTimeFormat.bind.apply(RelativeTimeFormat, __spreadArrays([void 0], args)))();
            }, {
                cache: createFastMemoizeCache$1(cache.relativeTime),
                strategy: memoizeIntl$1.strategies.variadic,
            }),
            getPluralRules: getPluralRules,
            getListFormat: memoizeIntl$1(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return new (ListFormat.bind.apply(ListFormat, __spreadArrays([void 0], args)))();
            }, {
                cache: createFastMemoizeCache$1(cache.list),
                strategy: memoizeIntl$1.strategies.variadic,
            }),
            getDisplayNames: memoizeIntl$1(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return new (DisplayNames.bind.apply(DisplayNames, __spreadArrays([void 0], args)))();
            }, {
                cache: createFastMemoizeCache$1(cache.displayNames),
                strategy: memoizeIntl$1.strategies.variadic,
            }),
        };
    }
    function getNamedFormat(formats, type, name, onError) {
        var formatType = formats && formats[type];
        var format;
        if (formatType) {
            format = formatType[name];
        }
        if (format) {
            return format;
        }
        onError(new UnsupportedFormatterError("No " + type + " format named: " + name));
    }

    function setTimeZoneInOptions(opts, timeZone) {
        return Object.keys(opts).reduce(function (all, k) {
            all[k] = __assign({ timeZone: timeZone }, opts[k]);
            return all;
        }, {});
    }
    function deepMergeOptions(opts1, opts2) {
        var keys = Object.keys(__assign(__assign({}, opts1), opts2));
        return keys.reduce(function (all, k) {
            all[k] = __assign(__assign({}, (opts1[k] || {})), (opts2[k] || {}));
            return all;
        }, {});
    }
    function deepMergeFormatsAndSetTimeZone(f1, timeZone) {
        if (!timeZone) {
            return f1;
        }
        var mfFormats = IntlMessageFormat.formats;
        return __assign(__assign(__assign({}, mfFormats), f1), { date: deepMergeOptions(setTimeZoneInOptions(mfFormats.date, timeZone), setTimeZoneInOptions(f1.date || {}, timeZone)), time: deepMergeOptions(setTimeZoneInOptions(mfFormats.time, timeZone), setTimeZoneInOptions(f1.time || {}, timeZone)) });
    }
    function formatMessage(_a, state, messageDescriptor, values) {
        var locale = _a.locale, formats = _a.formats, messages = _a.messages, defaultLocale = _a.defaultLocale, defaultFormats = _a.defaultFormats, onError = _a.onError, timeZone = _a.timeZone, defaultRichTextElements = _a.defaultRichTextElements;
        if (messageDescriptor === void 0) { messageDescriptor = { id: '' }; }
        var msgId = messageDescriptor.id, defaultMessage = messageDescriptor.defaultMessage;
        // `id` is a required field of a Message Descriptor.
        invariant(!!msgId, '[@formatjs/intl] An `id` must be provided to format a message.');
        var id = String(msgId);
        var message = 
        // In case messages is Object.create(null)
        // e.g import('foo.json') from webpack)
        // See https://github.com/formatjs/formatjs/issues/1914
        messages &&
            Object.prototype.hasOwnProperty.call(messages, id) &&
            messages[id];
        // IMPORTANT: Hot path if `message` is AST with a single literal node
        if (Array.isArray(message) &&
            message.length === 1 &&
            message[0].type === dummy.TYPE.literal) {
            return message[0].value;
        }
        if (!values &&
            message &&
            typeof message === 'string' &&
            defaultRichTextElements) {
            console.warn("[@formatjs/intl] \"defaultRichTextElements\" was specified but \"message\" was not pre-compiled. \nPlease consider using \"@formatjs/cli\" to pre-compile your messages for performance.\nFor more details see https://formatjs.io/docs/getting-started/message-distribution");
        }
        // IMPORTANT: Hot path straight lookup for performance
        if (!values &&
            message &&
            typeof message === 'string' &&
            !defaultRichTextElements) {
            return message.replace(/'\{(.*?)\}'/gi, "{$1}");
        }
        values = __assign(__assign({}, defaultRichTextElements), (values || {}));
        formats = deepMergeFormatsAndSetTimeZone(formats, timeZone);
        defaultFormats = deepMergeFormatsAndSetTimeZone(defaultFormats, timeZone);
        if (!message) {
            if (!defaultMessage ||
                (locale && locale.toLowerCase() !== defaultLocale.toLowerCase())) {
                // This prevents warnings from littering the console in development
                // when no `messages` are passed into the <IntlProvider> for the
                // default locale.
                onError(new MissingTranslationError(messageDescriptor, locale));
            }
            if (defaultMessage) {
                try {
                    var formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats);
                    return formatter.format(values);
                }
                catch (e) {
                    onError(new MessageFormatError("Error formatting default message for: \"" + id + "\", rendering default message verbatim", locale, messageDescriptor, e));
                    return typeof defaultMessage === 'string' ? defaultMessage : id;
                }
            }
            return id;
        }
        // We have the translated message
        try {
            var formatter = state.getMessageFormat(message, locale, formats, {
                formatters: state,
            });
            return formatter.format(values);
        }
        catch (e) {
            onError(new MessageFormatError("Error formatting message: \"" + id + "\", using " + (defaultMessage ? 'default message' : 'id') + " as fallback.", locale, messageDescriptor, e));
        }
        if (defaultMessage) {
            try {
                var formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats);
                return formatter.format(values);
            }
            catch (e) {
                onError(new MessageFormatError("Error formatting the default message for: \"" + id + "\", rendering message verbatim", locale, messageDescriptor, e));
            }
        }
        if (typeof message === 'string') {
            return message;
        }
        if (typeof defaultMessage === 'string') {
            return defaultMessage;
        }
        return id;
    }

    var DATE_TIME_FORMAT_OPTIONS = [
        'localeMatcher',
        'formatMatcher',
        'timeZone',
        'hour12',
        'weekday',
        'era',
        'year',
        'month',
        'day',
        'hour',
        'minute',
        'second',
        'timeZoneName',
        'hourCycle',
        'dateStyle',
        'timeStyle',
        'fractionalSecondDigits',
        'calendar',
        // 'dayPeriod',
        'numberingSystem',
    ];
    function getFormatter(_a, type, getDateTimeFormat, options) {
        var locale = _a.locale, formats = _a.formats, onError = _a.onError, timeZone = _a.timeZone;
        if (options === void 0) { options = {}; }
        var format = options.format;
        var defaults = __assign(__assign({}, (timeZone && { timeZone: timeZone })), (format && getNamedFormat(formats, type, format, onError)));
        var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults);
        if (type === 'time' &&
            !filteredOptions.hour &&
            !filteredOptions.minute &&
            !filteredOptions.second) {
            // Add default formatting options if hour, minute, or second isn't defined.
            filteredOptions = __assign(__assign({}, filteredOptions), { hour: 'numeric', minute: 'numeric' });
        }
        return getDateTimeFormat(locale, filteredOptions);
    }
    function formatDate(config, getDateTimeFormat) {
        var _a = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            _a[_i - 2] = arguments[_i];
        }
        var value = _a[0], _b = _a[1], options = _b === void 0 ? {} : _b;
        var date = typeof value === 'string' ? new Date(value || 0) : value;
        try {
            return getFormatter(config, 'date', getDateTimeFormat, options).format(date);
        }
        catch (e) {
            config.onError(new IntlError("FORMAT_ERROR" /* FORMAT_ERROR */, 'Error formatting date.', e));
        }
        return String(date);
    }
    function formatTime(config, getDateTimeFormat) {
        var _a = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            _a[_i - 2] = arguments[_i];
        }
        var value = _a[0], _b = _a[1], options = _b === void 0 ? {} : _b;
        var date = typeof value === 'string' ? new Date(value || 0) : value;
        try {
            return getFormatter(config, 'time', getDateTimeFormat, options).format(date);
        }
        catch (e) {
            config.onError(new IntlError("FORMAT_ERROR" /* FORMAT_ERROR */, 'Error formatting time.', e));
        }
        return String(date);
    }
    function formatDateTimeRange(config, getDateTimeFormat) {
        var _a = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            _a[_i - 2] = arguments[_i];
        }
        var from = _a[0], to = _a[1], _b = _a[2], options = _b === void 0 ? {} : _b;
        var timeZone = config.timeZone, locale = config.locale, onError = config.onError;
        var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, timeZone ? { timeZone: timeZone } : {});
        try {
            return getDateTimeFormat(locale, filteredOptions).formatRange(from, to);
        }
        catch (e) {
            onError(new IntlError("FORMAT_ERROR" /* FORMAT_ERROR */, 'Error formatting date time range.', e));
        }
        return String(from);
    }
    function formatDateToParts(config, getDateTimeFormat) {
        var _a = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            _a[_i - 2] = arguments[_i];
        }
        var value = _a[0], _b = _a[1], options = _b === void 0 ? {} : _b;
        var date = typeof value === 'string' ? new Date(value || 0) : value;
        try {
            return getFormatter(config, 'date', getDateTimeFormat, options).formatToParts(date);
        }
        catch (e) {
            config.onError(new IntlError("FORMAT_ERROR" /* FORMAT_ERROR */, 'Error formatting date.', e));
        }
        return [];
    }
    function formatTimeToParts(config, getDateTimeFormat) {
        var _a = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            _a[_i - 2] = arguments[_i];
        }
        var value = _a[0], _b = _a[1], options = _b === void 0 ? {} : _b;
        var date = typeof value === 'string' ? new Date(value || 0) : value;
        try {
            return getFormatter(config, 'time', getDateTimeFormat, options).formatToParts(date);
        }
        catch (e) {
            config.onError(new IntlError("FORMAT_ERROR" /* FORMAT_ERROR */, 'Error formatting time.', e));
        }
        return [];
    }

    var DISPLAY_NAMES_OPTONS = [
        'localeMatcher',
        'style',
        'type',
        'fallback',
    ];
    function formatDisplayName(_a, getDisplayNames, value, options) {
        var locale = _a.locale, onError = _a.onError;
        var DisplayNames = Intl.DisplayNames;
        if (!DisplayNames) {
            onError(new FormatError("Intl.DisplayNames is not available in this environment.\nTry polyfilling it using \"@formatjs/intl-displaynames\"\n", "MISSING_INTL_API" /* MISSING_INTL_API */));
        }
        var filteredOptions = filterProps(options, DISPLAY_NAMES_OPTONS);
        try {
            return getDisplayNames(locale, filteredOptions).of(value);
        }
        catch (e) {
            onError(new IntlError("FORMAT_ERROR" /* FORMAT_ERROR */, 'Error formatting display name.', e));
        }
    }

    var LIST_FORMAT_OPTIONS = [
        'localeMatcher',
        'type',
        'style',
    ];
    var now = Date.now();
    function generateToken(i) {
        return now + "_" + i + "_" + now;
    }
    function formatList(_a, getListFormat, values, options) {
        var locale = _a.locale, onError = _a.onError;
        if (options === void 0) { options = {}; }
        var ListFormat = Intl.ListFormat;
        if (!ListFormat) {
            onError(new FormatError("Intl.ListFormat is not available in this environment.\nTry polyfilling it using \"@formatjs/intl-listformat\"\n", "MISSING_INTL_API" /* MISSING_INTL_API */));
        }
        var filteredOptions = filterProps(options, LIST_FORMAT_OPTIONS);
        try {
            var richValues_1 = {};
            var serializedValues = values.map(function (v, i) {
                if (typeof v === 'object') {
                    var id = generateToken(i);
                    richValues_1[id] = v;
                    return id;
                }
                return String(v);
            });
            if (!Object.keys(richValues_1).length) {
                return getListFormat(locale, filteredOptions).format(serializedValues);
            }
            var parts = getListFormat(locale, filteredOptions).formatToParts(serializedValues);
            return parts.reduce(function (all, el) {
                var val = el.value;
                if (richValues_1[val]) {
                    all.push(richValues_1[val]);
                }
                else if (typeof all[all.length - 1] === 'string') {
                    all[all.length - 1] += val;
                }
                else {
                    all.push(val);
                }
                return all;
            }, []);
        }
        catch (e) {
            onError(new IntlError("FORMAT_ERROR" /* FORMAT_ERROR */, 'Error formatting list.', e));
        }
        // @ts-ignore
        return values;
    }

    var PLURAL_FORMAT_OPTIONS = [
        'localeMatcher',
        'type',
    ];
    function formatPlural(_a, getPluralRules, value, options) {
        var locale = _a.locale, onError = _a.onError;
        if (options === void 0) { options = {}; }
        if (!Intl.PluralRules) {
            onError(new FormatError("Intl.PluralRules is not available in this environment.\nTry polyfilling it using \"@formatjs/intl-pluralrules\"\n", "MISSING_INTL_API" /* MISSING_INTL_API */));
        }
        var filteredOptions = filterProps(options, PLURAL_FORMAT_OPTIONS);
        try {
            return getPluralRules(locale, filteredOptions).select(value);
        }
        catch (e) {
            onError(new MessageFormatError('Error formatting plural.', e));
        }
        return 'other';
    }

    var RELATIVE_TIME_FORMAT_OPTIONS = ['numeric', 'style'];
    function getFormatter$1(_a, getRelativeTimeFormat, options) {
        var locale = _a.locale, formats = _a.formats, onError = _a.onError;
        if (options === void 0) { options = {}; }
        var format = options.format;
        var defaults = (!!format && getNamedFormat(formats, 'relative', format, onError)) || {};
        var filteredOptions = filterProps(options, RELATIVE_TIME_FORMAT_OPTIONS, defaults);
        return getRelativeTimeFormat(locale, filteredOptions);
    }
    function formatRelativeTime(config, getRelativeTimeFormat, value, unit, options) {
        if (options === void 0) { options = {}; }
        if (!unit) {
            unit = 'second';
        }
        var RelativeTimeFormat = Intl.RelativeTimeFormat;
        if (!RelativeTimeFormat) {
            config.onError(new FormatError("Intl.RelativeTimeFormat is not available in this environment.\nTry polyfilling it using \"@formatjs/intl-relativetimeformat\"\n", "MISSING_INTL_API" /* MISSING_INTL_API */));
        }
        try {
            return getFormatter$1(config, getRelativeTimeFormat, options).format(value, unit);
        }
        catch (e) {
            config.onError(new MessageFormatError('Error formatting relative time.', e));
        }
        return String(value);
    }

    var NUMBER_FORMAT_OPTIONS = [
        'localeMatcher',
        'style',
        'currency',
        'currencyDisplay',
        'unit',
        'unitDisplay',
        'useGrouping',
        'minimumIntegerDigits',
        'minimumFractionDigits',
        'maximumFractionDigits',
        'minimumSignificantDigits',
        'maximumSignificantDigits',
        // ES2020 NumberFormat
        'compactDisplay',
        'currencyDisplay',
        'currencySign',
        'notation',
        'signDisplay',
        'unit',
        'unitDisplay',
    ];
    function getFormatter$2(_a, getNumberFormat, options) {
        var locale = _a.locale, formats = _a.formats, onError = _a.onError;
        if (options === void 0) { options = {}; }
        var format = options.format;
        var defaults = ((format &&
            getNamedFormat(formats, 'number', format, onError)) ||
            {});
        var filteredOptions = filterProps(options, NUMBER_FORMAT_OPTIONS, defaults);
        return getNumberFormat(locale, filteredOptions);
    }
    function formatNumber(config, getNumberFormat, value, options) {
        if (options === void 0) { options = {}; }
        try {
            return getFormatter$2(config, getNumberFormat, options).format(value);
        }
        catch (e) {
            config.onError(new IntlError("FORMAT_ERROR" /* FORMAT_ERROR */, 'Error formatting number.', e));
        }
        return String(value);
    }
    function formatNumberToParts(config, getNumberFormat, value, options) {
        if (options === void 0) { options = {}; }
        try {
            return getFormatter$2(config, getNumberFormat, options).formatToParts(value);
        }
        catch (e) {
            config.onError(new IntlError("FORMAT_ERROR" /* FORMAT_ERROR */, 'Error formatting number.', e));
        }
        return [];
    }

    /**
     * Create intl object
     * @param config intl config
     * @param cache cache for formatter instances to prevent memory leak
     */
    function createIntl(config, cache) {
        var formatters = createFormatters(cache);
        var resolvedConfig = __assign(__assign({}, DEFAULT_INTL_CONFIG), config);
        var locale = resolvedConfig.locale, defaultLocale = resolvedConfig.defaultLocale, onError = resolvedConfig.onError;
        if (!locale) {
            if (onError) {
                onError(new InvalidConfigError("\"locale\" was not configured, using \"" + defaultLocale + "\" as fallback. See https://formatjs.io/docs/react-intl/api#intlshape for more details"));
            }
            // Since there's no registered locale data for `locale`, this will
            // fallback to the `defaultLocale` to make sure things can render.
            // The `messages` are overridden to the `defaultProps` empty object
            // to maintain referential equality across re-renders. It's assumed
            // each <FormattedMessage> contains a `defaultMessage` prop.
            resolvedConfig.locale = resolvedConfig.defaultLocale || 'en';
        }
        else if (!Intl.NumberFormat.supportedLocalesOf(locale).length && onError) {
            onError(new MissingDataError("Missing locale data for locale: \"" + locale + "\" in Intl.NumberFormat. Using default locale: \"" + defaultLocale + "\" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details"));
        }
        else if (!Intl.DateTimeFormat.supportedLocalesOf(locale).length &&
            onError) {
            onError(new MissingDataError("Missing locale data for locale: \"" + locale + "\" in Intl.DateTimeFormat. Using default locale: \"" + defaultLocale + "\" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details"));
        }
        return __assign(__assign({}, resolvedConfig), { formatters: formatters, formatNumber: formatNumber.bind(null, resolvedConfig, formatters.getNumberFormat), formatNumberToParts: formatNumberToParts.bind(null, resolvedConfig, formatters.getNumberFormat), formatRelativeTime: formatRelativeTime.bind(null, resolvedConfig, formatters.getRelativeTimeFormat), formatDate: formatDate.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatDateToParts: formatDateToParts.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatTime: formatTime.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatDateTimeRange: formatDateTimeRange.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatTimeToParts: formatTimeToParts.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatPlural: formatPlural.bind(null, resolvedConfig, formatters.getPluralRules), formatMessage: formatMessage.bind(null, resolvedConfig, formatters), formatList: formatList.bind(null, resolvedConfig, formatters.getListFormat), formatDisplayName: formatDisplayName.bind(null, resolvedConfig, formatters.getDisplayNames) });
    }

    function invariantIntlContext(intl) {
        invariant(intl, '[React Intl] Could not find required `intl` object. ' +
            '<IntlProvider> needs to exist in the component ancestry.');
    }
    var DEFAULT_INTL_CONFIG$1 = __assign(__assign({}, DEFAULT_INTL_CONFIG), { textComponent: React.Fragment });
    /**
     * Takes a `formatXMLElementFn`, and composes it in function, which passes
     * argument `parts` through, assigning unique key to each part, to prevent
     * "Each child in a list should have a unique "key"" React error.
     * @param formatXMLElementFn
     */
    function assignUniqueKeysToParts(formatXMLElementFn) {
        return function (parts) {
            // eslint-disable-next-line prefer-rest-params
            return formatXMLElementFn(React.Children.toArray(parts));
        };
    }

    /** @license React v16.13.1
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
    Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
    function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}var AsyncMode=l;var ConcurrentMode=m;var ContextConsumer=k;var ContextProvider=h;var Element=c;var ForwardRef=n;var Fragment=e;var Lazy=t;var Memo=r;var Portal=d;
    var Profiler=g;var StrictMode=f;var Suspense=p;var isAsyncMode=function(a){return A(a)||z(a)===l};var isConcurrentMode=A;var isContextConsumer=function(a){return z(a)===k};var isContextProvider=function(a){return z(a)===h};var isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};var isForwardRef=function(a){return z(a)===n};var isFragment=function(a){return z(a)===e};var isLazy=function(a){return z(a)===t};
    var isMemo=function(a){return z(a)===r};var isPortal=function(a){return z(a)===d};var isProfiler=function(a){return z(a)===g};var isStrictMode=function(a){return z(a)===f};var isSuspense=function(a){return z(a)===p};
    var isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};var typeOf=z;

    var reactIs_production_min = {
    	AsyncMode: AsyncMode,
    	ConcurrentMode: ConcurrentMode,
    	ContextConsumer: ContextConsumer,
    	ContextProvider: ContextProvider,
    	Element: Element,
    	ForwardRef: ForwardRef,
    	Fragment: Fragment,
    	Lazy: Lazy,
    	Memo: Memo,
    	Portal: Portal,
    	Profiler: Profiler,
    	StrictMode: StrictMode,
    	Suspense: Suspense,
    	isAsyncMode: isAsyncMode,
    	isConcurrentMode: isConcurrentMode,
    	isContextConsumer: isContextConsumer,
    	isContextProvider: isContextProvider,
    	isElement: isElement,
    	isForwardRef: isForwardRef,
    	isFragment: isFragment,
    	isLazy: isLazy,
    	isMemo: isMemo,
    	isPortal: isPortal,
    	isProfiler: isProfiler,
    	isStrictMode: isStrictMode,
    	isSuspense: isSuspense,
    	isValidElementType: isValidElementType,
    	typeOf: typeOf
    };

    var reactIs = createCommonjsModule(function (module) {

    {
      module.exports = reactIs_production_min;
    }
    });

    /**
     * Copyright 2015, Yahoo! Inc.
     * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
     */
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      '$$typeof': true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      '$$typeof': true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

    function getStatics(component) {
      // React v16.11 and below
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      } // React v16.12 and above


      return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
    }

    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== 'string') {
        // don't hoist over string (html) components
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);

          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);

        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];

          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

            try {
              // Avoid failures from read-only properties
              defineProperty(targetComponent, key, descriptor);
            } catch (e) {}
          }
        }
      }

      return targetComponent;
    }

    var hoistNonReactStatics_cjs = hoistNonReactStatics;

    // Since rollup cannot deal with namespace being a function,
    // this is to interop with TypeScript since `invariant`
    // does not export a default
    // https://github.com/rollup/rollup/issues/1267
    var hoistNonReactStatics$1 = hoistNonReactStatics_cjs.default || hoistNonReactStatics_cjs;
    function getDisplayName(Component) {
        return Component.displayName || Component.name || 'Component';
    }
    // TODO: We should provide initial value here
    var IntlContext = React.createContext(null);
    var IntlConsumer = IntlContext.Consumer, IntlProvider = IntlContext.Provider;
    var Provider = IntlProvider;
    var Context = IntlContext;
    function injectIntl(WrappedComponent, options) {
        var _a = options || {}, _b = _a.intlPropName, intlPropName = _b === void 0 ? 'intl' : _b, _c = _a.forwardRef, forwardRef = _c === void 0 ? false : _c, _d = _a.enforceContext, enforceContext = _d === void 0 ? true : _d;
        var WithIntl = function (props) { return (React.createElement(IntlConsumer, null, function (intl) {
            var _a;
            if (enforceContext) {
                invariantIntlContext(intl);
            }
            var intlProp = (_a = {}, _a[intlPropName] = intl, _a);
            return (React.createElement(WrappedComponent, __assign({}, props, intlProp, { ref: forwardRef ? props.forwardedRef : null })));
        })); };
        WithIntl.displayName = "injectIntl(" + getDisplayName(WrappedComponent) + ")";
        WithIntl.WrappedComponent = WrappedComponent;
        if (forwardRef) {
            return hoistNonReactStatics$1(React.forwardRef(function (props, ref) { return (React.createElement(WithIntl, __assign({}, props, { forwardedRef: ref }))); }), WrappedComponent);
        }
        return hoistNonReactStatics$1(WithIntl, WrappedComponent);
    }

    var DisplayName;
    (function (DisplayName) {
        DisplayName["formatDate"] = "FormattedDate";
        DisplayName["formatTime"] = "FormattedTime";
        DisplayName["formatNumber"] = "FormattedNumber";
        DisplayName["formatList"] = "FormattedList";
        // Note that this DisplayName is the locale display name, not to be confused with
        // the name of the enum, which is for React component display name in dev tools.
        DisplayName["formatDisplayName"] = "FormattedDisplayName";
    })(DisplayName || (DisplayName = {}));
    var DisplayNameParts;
    (function (DisplayNameParts) {
        DisplayNameParts["formatDate"] = "FormattedDateParts";
        DisplayNameParts["formatTime"] = "FormattedTimeParts";
        DisplayNameParts["formatNumber"] = "FormattedNumberParts";
        DisplayNameParts["formatList"] = "FormattedListParts";
    })(DisplayNameParts || (DisplayNameParts = {}));
    var FormattedNumberParts = function (props) { return (React.createElement(Context.Consumer, null, function (intl) {
        invariantIntlContext(intl);
        var value = props.value, children = props.children, formatProps = __rest(props, ["value", "children"]);
        return children(intl.formatNumberToParts(value, formatProps));
    })); };
    FormattedNumberParts.displayName = 'FormattedNumberParts';
    function createFormattedDateTimePartsComponent(name) {
        var ComponentParts = function (props) { return (React.createElement(Context.Consumer, null, function (intl) {
            invariantIntlContext(intl);
            var value = props.value, children = props.children, formatProps = __rest(props, ["value", "children"]);
            var date = typeof value === 'string' ? new Date(value || 0) : value;
            var formattedParts = name === 'formatDate'
                ? intl.formatDateToParts(date, formatProps)
                : intl.formatTimeToParts(date, formatProps);
            return children(formattedParts);
        })); };
        ComponentParts.displayName = DisplayNameParts[name];
        return ComponentParts;
    }
    function createFormattedComponent(name) {
        var Component = function (props) { return (React.createElement(Context.Consumer, null, function (intl) {
            invariantIntlContext(intl);
            var value = props.value, children = props.children, formatProps = __rest(props, ["value", "children"]);
            // TODO: fix TS type definition for localeMatcher upstream
            var formattedValue = intl[name](value, formatProps);
            if (typeof children === 'function') {
                return children(formattedValue);
            }
            var Text = intl.textComponent || React.Fragment;
            return React.createElement(Text, null, formattedValue);
        })); };
        Component.displayName = DisplayName[name];
        return Component;
    }

    function useIntl() {
        var intl = React.useContext(Context);
        invariantIntlContext(intl);
        return intl;
    }

    function shallowEqualObjects(objA, objB) {
      if (objA === objB) {
        return true;
      }

      if (!objA || !objB) {
        return false;
      }

      var aKeys = Object.keys(objA);
      var bKeys = Object.keys(objB);
      var len = aKeys.length;

      if (bKeys.length !== len) {
        return false;
      }

      for (var i = 0; i < len; i++) {
        var key = aKeys[i];

        if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {
          return false;
        }
      }

      return true;
    }

    var objects = shallowEqualObjects;

    var shallowEquals_ = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), objects, {
        'default': objects
    }));

    /*
     * Copyright 2015, Yahoo Inc.
     * Copyrights licensed under the New BSD License.
     * See the accompanying LICENSE file for terms.
     */
    var shallowEquals = objects || shallowEquals_;
    function processIntlConfig(config) {
        return {
            locale: config.locale,
            timeZone: config.timeZone,
            formats: config.formats,
            textComponent: config.textComponent,
            messages: config.messages,
            defaultLocale: config.defaultLocale,
            defaultFormats: config.defaultFormats,
            onError: config.onError,
            wrapRichTextChunksInFragment: config.wrapRichTextChunksInFragment,
            defaultRichTextElements: config.defaultRichTextElements,
        };
    }
    function assignUniqueKeysToFormatXMLElementFnArgument(values) {
        if (!values) {
            return values;
        }
        return Object.keys(values).reduce(function (acc, k) {
            var v = values[k];
            acc[k] = isFormatXMLElementFn(v)
                ? assignUniqueKeysToParts(v)
                : v;
            return acc;
        }, {});
    }
    var formatMessage$1 = function (config, formatters, descriptor, rawValues) {
        var values = assignUniqueKeysToFormatXMLElementFnArgument(rawValues);
        var chunks = formatMessage(config, formatters, descriptor, values);
        if (Array.isArray(chunks)) {
            return React.Children.toArray(chunks);
        }
        return chunks;
    };
    /**
     * Create intl object
     * @param config intl config
     * @param cache cache for formatter instances to prevent memory leak
     */
    var createIntl$1 = function (_a, cache) {
        var rawDefaultRichTextElements = _a.defaultRichTextElements, config = __rest(_a, ["defaultRichTextElements"]);
        var defaultRichTextElements = assignUniqueKeysToFormatXMLElementFnArgument(rawDefaultRichTextElements);
        var coreIntl = createIntl(__assign(__assign({}, DEFAULT_INTL_CONFIG$1), config), cache);
        return __assign(__assign({}, coreIntl), { formatMessage: formatMessage$1.bind(null, {
                locale: coreIntl.locale,
                timeZone: coreIntl.timeZone,
                formats: coreIntl.formats,
                defaultLocale: coreIntl.defaultLocale,
                defaultFormats: coreIntl.defaultFormats,
                messages: coreIntl.messages,
                onError: coreIntl.onError,
                defaultRichTextElements: defaultRichTextElements,
            }, coreIntl.formatters) });
    };
    var IntlProvider$1 = /** @class */ (function (_super) {
        __extends(IntlProvider, _super);
        function IntlProvider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.cache = createIntlCache();
            _this.state = {
                cache: _this.cache,
                intl: createIntl$1(processIntlConfig(_this.props), _this.cache),
                prevConfig: processIntlConfig(_this.props),
            };
            return _this;
        }
        IntlProvider.getDerivedStateFromProps = function (props, _a) {
            var prevConfig = _a.prevConfig, cache = _a.cache;
            var config = processIntlConfig(props);
            if (!shallowEquals(prevConfig, config)) {
                return {
                    intl: createIntl$1(config, cache),
                    prevConfig: config,
                };
            }
            return null;
        };
        IntlProvider.prototype.render = function () {
            invariantIntlContext(this.state.intl);
            return React.createElement(Provider, { value: this.state.intl }, this.props.children);
        };
        IntlProvider.displayName = 'IntlProvider';
        IntlProvider.defaultProps = DEFAULT_INTL_CONFIG$1;
        return IntlProvider;
    }(React.PureComponent));

    var MINUTE = 60;
    var HOUR = 60 * 60;
    var DAY = 60 * 60 * 24;
    function selectUnit(seconds) {
        var absValue = Math.abs(seconds);
        if (absValue < MINUTE) {
            return 'second';
        }
        if (absValue < HOUR) {
            return 'minute';
        }
        if (absValue < DAY) {
            return 'hour';
        }
        return 'day';
    }
    function getDurationInSeconds(unit) {
        switch (unit) {
            case 'second':
                return 1;
            case 'minute':
                return MINUTE;
            case 'hour':
                return HOUR;
            default:
                return DAY;
        }
    }
    function valueToSeconds(value, unit) {
        if (!value) {
            return 0;
        }
        switch (unit) {
            case 'second':
                return value;
            case 'minute':
                return value * MINUTE;
            default:
                return value * HOUR;
        }
    }
    var INCREMENTABLE_UNITS = ['second', 'minute', 'hour'];
    function canIncrement(unit) {
        if (unit === void 0) { unit = 'second'; }
        return INCREMENTABLE_UNITS.includes(unit);
    }
    var FormattedRelativeTime = /** @class */ (function (_super) {
        __extends(FormattedRelativeTime, _super);
        function FormattedRelativeTime(props) {
            var _this = _super.call(this, props) || this;
            // Public for testing
            _this._updateTimer = null;
            _this.state = {
                prevUnit: _this.props.unit,
                prevValue: _this.props.value,
                currentValueInSeconds: canIncrement(_this.props.unit)
                    ? valueToSeconds(_this.props.value, _this.props.unit)
                    : 0,
            };
            invariant(!props.updateIntervalInSeconds ||
                !!(props.updateIntervalInSeconds && canIncrement(props.unit)), 'Cannot schedule update with unit longer than hour');
            return _this;
        }
        FormattedRelativeTime.prototype.scheduleNextUpdate = function (_a, _b) {
            var _this = this;
            var updateIntervalInSeconds = _a.updateIntervalInSeconds, unit = _a.unit;
            var currentValueInSeconds = _b.currentValueInSeconds;
            clearTimeout(this._updateTimer);
            this._updateTimer = null;
            // If there's no interval and we cannot increment this unit, do nothing
            if (!updateIntervalInSeconds || !canIncrement(unit)) {
                return;
            }
            // Figure out the next interesting time
            var nextValueInSeconds = currentValueInSeconds - updateIntervalInSeconds;
            var nextUnit = selectUnit(nextValueInSeconds);
            // We've reached the max auto incrementable unit, don't schedule another update
            if (nextUnit === 'day') {
                return;
            }
            var unitDuration = getDurationInSeconds(nextUnit);
            var remainder = nextValueInSeconds % unitDuration;
            var prevInterestingValueInSeconds = nextValueInSeconds - remainder;
            var nextInterestingValueInSeconds = prevInterestingValueInSeconds >= currentValueInSeconds
                ? prevInterestingValueInSeconds - unitDuration
                : prevInterestingValueInSeconds;
            var delayInSeconds = Math.abs(nextInterestingValueInSeconds - currentValueInSeconds);
            this._updateTimer = setTimeout(function () {
                return _this.setState({
                    currentValueInSeconds: nextInterestingValueInSeconds,
                });
            }, delayInSeconds * 1e3);
        };
        FormattedRelativeTime.prototype.componentDidMount = function () {
            this.scheduleNextUpdate(this.props, this.state);
        };
        FormattedRelativeTime.prototype.componentDidUpdate = function () {
            this.scheduleNextUpdate(this.props, this.state);
        };
        FormattedRelativeTime.prototype.componentWillUnmount = function () {
            clearTimeout(this._updateTimer);
            this._updateTimer = null;
        };
        FormattedRelativeTime.getDerivedStateFromProps = function (props, state) {
            if (props.unit !== state.prevUnit || props.value !== state.prevValue) {
                return {
                    prevValue: props.value,
                    prevUnit: props.unit,
                    currentValueInSeconds: canIncrement(props.unit)
                        ? valueToSeconds(props.value, props.unit)
                        : 0,
                };
            }
            return null;
        };
        FormattedRelativeTime.prototype.render = function () {
            var _this = this;
            return (React.createElement(Context.Consumer, null, function (intl) {
                invariantIntlContext(intl);
                var formatRelativeTime = intl.formatRelativeTime, Text = intl.textComponent;
                var _a = _this.props, children = _a.children, value = _a.value, unit = _a.unit, updateIntervalInSeconds = _a.updateIntervalInSeconds;
                var currentValueInSeconds = _this.state.currentValueInSeconds;
                var currentValue = value || 0;
                var currentUnit = unit;
                if (canIncrement(unit) &&
                    typeof currentValueInSeconds === 'number' &&
                    updateIntervalInSeconds) {
                    currentUnit = selectUnit(currentValueInSeconds);
                    var unitDuration = getDurationInSeconds(currentUnit);
                    currentValue = Math.round(currentValueInSeconds / unitDuration);
                }
                var formattedRelativeTime = formatRelativeTime(currentValue, currentUnit, __assign({}, _this.props));
                if (typeof children === 'function') {
                    return children(formattedRelativeTime);
                }
                if (Text) {
                    return React.createElement(Text, null, formattedRelativeTime);
                }
                return formattedRelativeTime;
            }));
        };
        FormattedRelativeTime.displayName = 'FormattedRelativeTime';
        FormattedRelativeTime.defaultProps = {
            value: 0,
            unit: 'second',
        };
        return FormattedRelativeTime;
    }(React.PureComponent));

    /*
     * Copyright 2015, Yahoo Inc.
     * Copyrights licensed under the New BSD License.
     * See the accompanying LICENSE file for terms.
     */
    var FormattedPlural = function (props) {
        var value = props.value, other = props.other, children = props.children, _a = props.intl, formatPlural = _a.formatPlural, Text = _a.textComponent;
        var pluralCategory = formatPlural(value, props);
        var formattedPlural = props[pluralCategory] || other;
        if (typeof children === 'function') {
            return children(formattedPlural);
        }
        if (Text) {
            return React.createElement(Text, null, formattedPlural);
        }
        // Work around @types/react where React.FC cannot return string
        return formattedPlural;
    };
    FormattedPlural.defaultProps = {
        type: 'cardinal',
    };
    FormattedPlural.displayName = 'FormattedPlural';
    // Explicitly annotate type here to workaround API extractor's inability to handle `import('./someModule')`
    // type annotations when rolling up DTS file.
    var FormattedPluralWithIntl = injectIntl(FormattedPlural);

    /*
     * Copyright 2015, Yahoo Inc.
     * Copyrights licensed under the New BSD License.
     * See the accompanying LICENSE file for terms.
     */
    var shallowEquals$1 = objects || shallowEquals_;
    var FormattedMessage = /** @class */ (function (_super) {
        __extends(FormattedMessage, _super);
        function FormattedMessage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormattedMessage.prototype.shouldComponentUpdate = function (nextProps) {
            var _a = this.props, values = _a.values, otherProps = __rest(_a, ["values"]);
            var nextValues = nextProps.values, nextOtherProps = __rest(nextProps, ["values"]);
            return (!shallowEquals$1(nextValues, values) ||
                !shallowEquals$1(otherProps, nextOtherProps));
        };
        FormattedMessage.prototype.render = function () {
            var _this = this;
            return (React.createElement(Context.Consumer, null, function (intl) {
                invariantIntlContext(intl);
                var formatMessage = intl.formatMessage, _a = intl.textComponent, Text = _a === void 0 ? React.Fragment : _a;
                var _b = _this.props, id = _b.id, description = _b.description, defaultMessage = _b.defaultMessage, values = _b.values, children = _b.children, _c = _b.tagName, Component = _c === void 0 ? Text : _c;
                var descriptor = { id: id, description: description, defaultMessage: defaultMessage };
                var nodes = formatMessage(descriptor, values);
                if (!Array.isArray(nodes)) {
                    nodes = [nodes];
                }
                if (typeof children === 'function') {
                    return children(nodes);
                }
                if (Component) {
                    // Needs to use `createElement()` instead of JSX, otherwise React will
                    // warn about a missing `key` prop with rich-text message formatting.
                    return React.createElement.apply(React__namespace, __spreadArrays([Component, null], nodes));
                }
                return nodes;
            }));
        };
        FormattedMessage.displayName = 'FormattedMessage';
        return FormattedMessage;
    }(React.Component));

    var FormattedDateTimeRange = function (props) { return (React.createElement(Context.Consumer, null, function (intl) {
        invariantIntlContext(intl);
        var from = props.from, to = props.to, children = props.children, formatProps = __rest(props, ["from", "to", "children"]);
        var formattedValue = intl.formatDateTimeRange(from, to, formatProps);
        if (typeof children === 'function') {
            return children(formattedValue);
        }
        var Text = intl.textComponent || React.Fragment;
        return React.createElement(Text, null, formattedValue);
    })); };
    FormattedDateTimeRange.displayName = 'FormattedDateTimeRange';

    function defineMessages(msgs) {
        return msgs;
    }
    function defineMessage(msg) {
        return msg;
    }
    // IMPORTANT: Explicit here to prevent api-extractor from outputing `import('./src/types').CustomFormatConfig`
    var FormattedDate = createFormattedComponent('formatDate');
    var FormattedTime = createFormattedComponent('formatTime');
    var FormattedNumber = createFormattedComponent('formatNumber');
    var FormattedList = createFormattedComponent('formatList');
    var FormattedDisplayName = createFormattedComponent('formatDisplayName');
    var FormattedDateParts = createFormattedDateTimePartsComponent('formatDate');
    var FormattedTimeParts = createFormattedDateTimePartsComponent('formatTime');

    exports.FormattedDate = FormattedDate;
    exports.FormattedDateParts = FormattedDateParts;
    exports.FormattedDateTimeRange = FormattedDateTimeRange;
    exports.FormattedDisplayName = FormattedDisplayName;
    exports.FormattedList = FormattedList;
    exports.FormattedMessage = FormattedMessage;
    exports.FormattedNumber = FormattedNumber;
    exports.FormattedNumberParts = FormattedNumberParts;
    exports.FormattedPlural = FormattedPluralWithIntl;
    exports.FormattedRelativeTime = FormattedRelativeTime;
    exports.FormattedTime = FormattedTime;
    exports.FormattedTimeParts = FormattedTimeParts;
    exports.IntlContext = Context;
    exports.IntlProvider = IntlProvider$1;
    exports.InvalidConfigError = InvalidConfigError;
    exports.MessageFormatError = MessageFormatError;
    exports.MissingDataError = MissingDataError;
    exports.MissingTranslationError = MissingTranslationError;
    exports.RawIntlProvider = Provider;
    exports.ReactIntlError = IntlError;
    exports.UnsupportedFormatterError = UnsupportedFormatterError;
    exports.createIntl = createIntl$1;
    exports.createIntlCache = createIntlCache;
    exports.defineMessage = defineMessage;
    exports.defineMessages = defineMessages;
    exports.injectIntl = injectIntl;
    exports.useIntl = useIntl;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=react-intl-no-parser.umd.js.map
